<?php
/**
 * RFI SMS Responder
 *
 * IMPORTANT: RFI Form needs to include hidden field: 'is_sms_enabled' via GravityForms config
 *
 *
 * @todo Refactors: Split Cron functions out into own file.
 * @todo Better UI on admin settings page. Better idiot-proofing so someone doesn't inadvertently delete something critical.
 * @todo ^^ Along that line, better error checking & handling within SMS_RFI logic.
 */

namespace NUedu_Forms\Inc;

/** SMS_RFI */
class SMS_RFI {

	// Config Constants: Field ID's for the Gravity Form we're using
	// We could grab these dynamically (like we do in our gf-doublepositive plugin), but these really shouldn't ever change.
	const GF_RFI_DEFAULT_FORM_ID   = 1;
	const FIELD_ID__DEGREE_PROGRAM = 33;
	const FIELD_ID__ZIPCODE        = 35;
	const FIELD_ID__SMS_ENABLED    = 65;
	const FIELD_ID__LEADGROUP      = 46;
	const FIELD_ID__PHONE          = 34;
	const FIELD_ID__COUNTRY_CODE   = 51;

	// Config Constants: Cron-related
	const SMS_DELAY_TIME_HOURS      = 0.5; // Testing: 0.016 (1 minute) - Production: 0.5 (30 minutes).
	const SMS_CRON_INTERVAL_SECONDS = 900; // Testing: 60 (1 minute)    - Production: 900 (15 minutes). [NOTE: WPVIP discourages anything shorter than 15 minutes on production.]
	const SMS_CUSTOM_TABLE          = 'wp_sms_rfi';

	// Config Constants: Misc
	const ZIPCODE_INTERNATIONAL = '00000'; // Based on form auto-populating 00000 for international entries.


	/** Constructor */
	public function __construct() {

		// Make sure Gravity Forms (and it's addon extensions) are loaded.
		if ( ! method_exists( 'GFForms', 'include_addon_framework' ) ) {
			return;
		}

		$this->is_sms_enabled = false;

		define( 'GF_NUS_SMS_VER', '2.0.0' );
		define( 'GF_NUS_SMS_PATH', plugin_dir_path( __FILE__ ) );
		define( 'GF_NUS_SMS_URL', plugin_dir_url( __FILE__ ) );

		/**
		 * Need to give hook priority of less than 10 -- our leadgroup & supplier ID values are generated by another NU plugin, both hooked to the gform_pre_submission hook.
		 * Since we modify those values for SMS submissions, we need to make sure action runs before those two actions.
		 */
		add_action( 'gform_pre_submission', [ $this, 'check_is_sms_enabled' ], 9 );

		/**
		 * Conditionally modify 'supplier ID' and 'leadgroup' if our form is SMS-enabled.
		 * These values are normally generated by other NU plugin: gravityforms-doublepositive/in/class-populate-fields.php
		 * Supplier ID we can just filter, based on how the code in the other plugin is written.
		 * LeadGroup we need to do differently, because our other plugin normally generates that value at a different point in the form submission cycle.
		 *
		 * @todo Still some confusion (not just on our end) about exactly how data is mapping to various third-parties. Per Claire Leong, might need to re-visit broader integrations at some point.
		 *        ^^ I don't think we need to modify the supplier ID. By setting our leadgroup, it causes the DoublePositive feed processing to stop and clears out the Supplier ID. Ref: plugins\gravityforms-doublepositive\inc\class-feed-processing.php
		 */
		add_action( 'gform_pre_submission', [ $this, 'modify_doublepositive_leadgroup'] );
		add_filter( 'gf_nus_modify_supplier_id', [ $this, 'modify_doublepositive_supplier_id' ] );

		// Generate Quiq API call on form submission (GravityForms hook).
		add_action( 'gform_after_submission', [ $this, 'generate_quiq_api' ], 10, 2 );

		// Manage cron schedule for delayed SMS #2.
		add_filter( 'cron_schedules', [ $this, 'sms_rfi_add_cron_interval' ] ); //phpcs:ignore -- interval set via defined constant above, for easy test cases.
		add_action( 'sms_cron_hook', [ $this, 'sms_cron_exec' ] );


		$this->register_settings();
		$this->fetch_saved_settings();
		$this->init_sms_cron();
	}


	/**
	 * Since WP's shortest native cron interval is hourly, add custom interval to check every 15 minutes.
	 *
	 * @param array $schedules cron schedules from wp.
	 * */
	public function sms_rfi_add_cron_interval( $schedules ) {

		$schedules['fifteen_minutes'] = [
			'interval' => self::SMS_CRON_INTERVAL_SECONDS,
			'display'  => esc_html__( 'Every Fifteen Minutes' ),
		];

		return $schedules;

	}

	/**
	 * Load & integrate custom admin settings with Gravity Forms
	 */
	public function register_settings() {
		if ( file_exists( GF_NUS_SMS_PATH . 'sms-rfi/class-gf-nus-sms-settings.php' ) ) {
			require_once GF_NUS_SMS_PATH . 'sms-rfi/class-gf-nus-sms-settings.php';
			\GFAddOn::register( 'GF_NUS_SMS_Settings' );
		}
	}

	/**
	 * Load SMS-related custom settings, saved via custom admin menu registered above
	 *
	 * @todo Save $enabled_programs as a transient for better performance? Presumably won't be changing frequently.
	 */
	public function fetch_saved_settings() {

		$instance       = \GF_NUS_SMS_Settings::get_instance();
		$this->settings = $instance->get_plugin_settings();

		$this->program_page_input = $this->settings['sms_pilot_program_titles'];
		$this->program_page_input = preg_replace("/\r|\n/", "", $this->program_page_input); // Since we're pulling from a textarea, remove all line breaks
		$this->enabled_programs   = explode( ',', $this->program_page_input );

		$this->api_connection = [
			'API_ENDPOINT'     => $this->settings['sms_quiq_api_endpoint'],
			'API_KEY'          => $this->settings['sms_quiq_api_key'],
			'API_SECRET'       => $this->settings['sms_quiq_api_secret'],
			'API_ACCESS_TOKEN' => $this->settings['sms_quiq_api_access_token'], // Currently unused.
			'API_TOKEN_ID'     => $this->settings['sms_quiq_api_token_id'], // Currently unused.
		];

		$this->quiq_config = [
			'CONTACT_POINT'     => $this->settings['sms_quiq_contact_point'],
			'DP_SUPPLIER_ID'    => intval( $this->settings['sms_doublepositive_supplier_id'] ),
			'DP_LEADGROUP'      => $this->settings['sms_doublepositive_leadgroup'],
			'TOPIC_1'           => $this->settings['sms_quiq_topic_1'],
			'TOPIC_2'           => $this->settings['sms_quiq_topic_2'],
			'MESSAGE_CONTENT_1' => $this->settings['sms_quiq_message_content_1'],
			'MESSAGE_CONTENT_2' => $this->settings['sms_quiq_message_content_2'],
		];

	}


	/**
	 * Check to see if this should be an SMS-enabled form.
	 * Fires on gform_pre_submission() hook.
	 * Note that GF has native functionality to only run on certain form id ('gform_pre_submission_1'for formID=1 )
	 * However we can't use that here because of other existing functions (Supplier ID & leadgroup generation, via other plugins) that hook into the normal gform_pre_submission.
	 * Need to check form ID manually instead.
	 *
	 * @param array $form -> Current form being submitted
	 * @return void
	 */
	public function check_is_sms_enabled( $form ) {

		// SMS should only run on 'RFI Default' form (GF form ID #1)
		if ( self::GF_RFI_DEFAULT_FORM_ID !== $form['id'] ) {
			$this->is_sms_enabled = false;
			return;
		}

		// Check if international (zipcode 00000), and abort if so.
		$zipcode_field_id    = self::FIELD_ID__ZIPCODE;
		$zipcode_field       = \GFAPI::get_field( $form, $zipcode_field_id );
		$zipcode_field_value = $zipcode_field->get_value_submission( [] );

		if ( self::ZIPCODE_INTERNATIONAL === $zipcode_field_value ) {
			$this->is_sms_enabled = false;
			return;
		}

		$sms_field_id        = self::FIELD_ID__SMS_ENABLED;
		$program_field_id    = self::FIELD_ID__DEGREE_PROGRAM;
		$program_field       = \GFAPI::get_field( $form, $program_field_id );
		$program_field_value = $program_field->get_value_submission( [] );

		$target_programs = $this->enabled_programs;

		$_POST[ 'input_' . $sms_field_id ] = in_array( $program_field_value, $target_programs ) ? true : false; // Set hidden 'SMS' field to true/false.
		$this->is_sms_enabled              = in_array( $program_field_value, $target_programs ) ? true : false;

	}


	/**
	 * Fn: modify_doublepositive_supplier_id()
	 *
	 * Need to intercept the $supplier_id generated by our GravityForms-DoublePositive custom plugin,
	 * and then replace that ID with 377996 (entered via custom wp-admin settings), which tells DoublePositive to ignore the standard phone call follow-up.
	 *
	 * Internal Reference: plugins/gravityforms-doublepositive/inc/class-populate-fields.php ==> populate_supplier_id()
	 *
	 * @todo This one's a bit weird. Enrollment team isn't entirely clear on how data is mapping from GF to DP/ELQ and then to OnDemand.
	 * 			Right now on a 'successful' SMS form submission, the supplier ID will be modified below, but then overwritten & cleared out later in the process (via gf-db plugin ref'd above)
	 * 			Ultimately a SMS form submission will not route to DoublePositive at all, and a supplier ID will not be saved to the entry.
	 * 			Enrollment team says they'll re-visit how data is mapping amongst their platforms -> if and when that happens, may need to modify the below.
	 *
	 * @param int $supplier_id -- DoublePositive Supplier ID generated by standard form submission.
	 * @return int $supplier_id -- Changed to 377996 if applicable, otherwise returned unchanged
	 */
	public function modify_doublepositive_supplier_id( $supplier_id ) {

		if ( $this->is_sms_enabled ){
			$supplier_id = $this->quiq_config['DP_SUPPLIER_ID'];
		}

		return $supplier_id;
	}

	/**
	 * Fn: modify_doublepositive_leadgroup()
	 *
	 * Need to intercept the $leadgroup generated by our GravityForms-DoublePositive custom plugin,
	 * and then replace that ID with 'NUSMSPilot'
	 *
	 * Reference: plugins/gravityforms-doublepositive/inc/class-feed-processing.php ==> share_dp_data_to_eloqua()
	 * Reference: https://docs.gravityforms.com/using-dynamic-population/
	 *
	 * @param string $leadgroup -- DoublePositive 'leadgroup' (generally set to "DP" on non-SMS forms).
	 */
	public function modify_doublepositive_leadgroup() {

		if ( $this->is_sms_enabled ){

			$leadgroup_field_id    = self::FIELD_ID__LEADGROUP;
			$leadgroup_field_value = $this->quiq_config['DP_LEADGROUP'];

			$_POST[ 'input_' . $leadgroup_field_id ] = $leadgroup_field_value;
		}

	}


	/**
	 * Generate API call to Quiq for SMS messaging
	 * Reference: https://developers.goquiq.com/api/docs#operation/Send%20notification
	 *
	 * Called via gform_after_submission hook
	 * ref https://docs.gravityforms.com/gform_after_submission/
	 *
	 * @param array $entry -- Data from the submitted form.
	 * @param array $form  -- Data about the form itself. Don't think we need this but leaving as a parameter for now, as a reminder that we have it if we need it.
	 *
	 */
	public function generate_quiq_api( $entry, $form ) {

		if ( ! $this->is_sms_enabled ) {
			return;
		}

		$input_phone_number = $entry[self::FIELD_ID__PHONE];
		$input_country_code = $entry[self::FIELD_ID__COUNTRY_CODE];
		$user_phone         = '+' . $input_country_code . $input_phone_number; // i.e. '+16513343186' .

		$url = $this->api_connection['API_ENDPOINT'];

		$data = [
			'handle'       => $user_phone,
			'contactPoint' => $this->quiq_config['CONTACT_POINT'],
			'message'      => [
				'text' => $this->quiq_config['MESSAGE_CONTENT_1'],
			],
			'topic'        => $this->quiq_config['TOPIC_1'],
		];

		$payload = wp_json_encode( $data );

		$args = [
			'body'    => $payload,
			'headers' => [
				'Authorization' => 'Basic ' . base64_encode( $this->api_connection['API_KEY'] . ':' . $this->api_connection['API_SECRET'] ),
				'Content-Type'  => 'application/json',
			],
		];

		$response = wp_remote_post( $url, $args );

		if ( 200 === $response['response']['code'] ) {

			// Schedule second API call.

			/**
			 * In plugin activation hook, we create a custom 'wp_sms_rfi' db table.
			 * We use this table to manage our SMS #2 schedule.
			 * Upon successful SMS #1 send, we create a db row for the phone number and timestamp.
			 * WP-Cron then uses this table to send out SMS #2 to all entries older than 30 minutes old.
			 *
			 * @todo if API call fails, should implement logic to process form normally
			 */

			global $wpdb;

			$table_name = self::SMS_CUSTOM_TABLE;
			$timestamp  = gmdate( 'Y-m-d H:i:s' );

			$table_data = [
				'phone_number'  => $user_phone,
				'rfi_timestamp' => $timestamp,
			];

			$wpdb->insert( $table_name, $table_data ); // phpcs:ignore WordPress.DB.DirectDatabaseQuery.DirectQuery

		}

	}


	/**
	 * Init cron event schedule.
	 *
	 * @return void
	 */
	public function init_sms_cron() {

		if ( ! wp_next_scheduled( 'sms_cron_hook' ) ) {
			wp_schedule_event( time(), 'fifteen_minutes', 'sms_cron_hook' );
		} else {
			$temp = gmdate( 'Y-m-d H:i:s', wp_next_scheduled( 'sms_cron_hook' ) );
		}

	}


	/**
	 * Execute cron job
	 *
	 * Fetch all rows from custom 'wp_sms_rfi' db table.
	 * Check 'timestamp' value for each row
	 * Any timestamp more than 24 hours old, send another Quiq API call with Message #2
	 * Then, delete the row from the table.
	 *
	 * @todo a lot of this was copy/pasted on the fly. Need to DRY it up at some point.
	 **/
	public function sms_cron_exec() {

		/**
		 * Fetch saved admin settings
		 *
		 * @todo could we just call $this->fetch_saved_settings() ?
		 */
		$instance               = \GF_NUS_SMS_Settings::get_instance();
		$this->settings         = $instance->get_plugin_settings();
		$this->program_page_ids = explode( ',', $this->settings['sms_pilot_program_page_ids'] );
		$this->api_connection   = [
			'API_ENDPOINT'     => $this->settings['sms_quiq_api_endpoint'],
			'API_KEY'          => $this->settings['sms_quiq_api_key'],
			'API_SECRET'       => $this->settings['sms_quiq_api_secret'],
			'API_ACCESS_TOKEN' => $this->settings['sms_quiq_api_access_token'], // Currently unused.
			'API_TOKEN_ID'     => $this->settings['sms_quiq_api_token_id'], // Currently unused.
		];

		$this->quiq_config = [
			'CONTACT_POINT'     => $this->settings['sms_quiq_contact_point'],
			'TOPIC_2'           => $this->settings['sms_quiq_topic_2'],
			'MESSAGE_CONTENT_2' => $this->settings['sms_quiq_message_content_2'],
			'DP_SUPPLIER_ID'    => intval( $this->settings['sms_doublepositive_supplier_id'] ),
			'DP_LEADGROUP'      => $this->settings['sms_doublepositive_leadgroup'],
		];



		$now = gmdate( 'Y-m-d H:i:s' ); // Match format we input into database.

		// Fetch wpdb rows from sms_rfi table.
		global $wpdb;

		$rows = $wpdb->get_results( // phpcs:ignore WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
			'
				SELECT *
				FROM wp_sms_rfi
				ORDER BY sms_id
			'
		);


		foreach ( $rows as $row ) {

			// Get difference between timestamp in hours.
			$diff = ( strtotime( $now ) - strtotime( $row->rfi_timestamp ) ) / ( 60 * 60 );

			// If timestamp is more than THIRTY MINUTES old, fire the API for SMS #2 and then delete the row from the table.
			if ( $diff >= self::SMS_DELAY_TIME_HOURS ) {

				$url = $this->api_connection['API_ENDPOINT'];

				$data = [
					'handle'       => $row->phone_number,
					'contactPoint' => $this->quiq_config['CONTACT_POINT'],
					'message'      => [
						'text' => $this->quiq_config['MESSAGE_CONTENT_2'],
					],
					'topic'        => $this->quiq_config['TOPIC_2'],
				];

				$payload = wp_json_encode( $data );

				$args = [
					'body'    => $payload,
					'headers' => [
						'Authorization' => 'Basic ' . base64_encode( $this->api_connection['API_KEY'] . ':' . $this->api_connection['API_SECRET'] ),
						'Content-Type'  => 'application/json',
					],
				];

				$response = wp_remote_post( $url, $args );

				if ( 200 === $response['response']['code'] ) {

					// If SMS #2 was sent successfully, delete the row from the table.
					$wpdb->delete( // phpcs:ignore WordPress.DB.DirectDatabaseQuery.DirectQuery, WordPress.DB.DirectDatabaseQuery.NoCaching
						'wp_sms_rfi',
						[ 'sms_id' => $row->sms_id ]
					);



				}
			}
		}


	}



}