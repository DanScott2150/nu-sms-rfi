<?php
/**
 * RFI SMS Responder
 *
 * @todo LOTS of potential for refactors & general cleanup. Currently pretty sloppy due to aggressive deadlines. Will re-visit.
 *         --> Probably makes sense to split data integrations (Eloqua/DP) and actual API calls into separate files. Cron-related funcs into separate as well.
 *
 * @todo Look into better way to identify SMS-enabled forms. Right now going off page ID, but there are some significant gaps/edge-cases this doesn't catch.
 * @todo Need waaaay better error-checking & data validation.
 */

namespace NUedu_Forms\Inc;

/**
 * SMS_RFI
 */
class SMS_RFI {

	/** Constructor */
	public function __construct() {

		// Make sure Gravity Forms (and it's addon extensions) are loaded.
		if ( ! method_exists( 'GFForms', 'include_addon_framework' ) ) {
			return;
		}

		define( 'GF_NUS_SMS_VER', '2.0.0' );
		define( 'GF_NUS_SMS_PATH', plugin_dir_path( __FILE__ ) );
		define( 'GF_NUS_SMS_URL', plugin_dir_url( __FILE__ ) );

		// Filter to intercept & overwrite 'Supplier ID' generated by DoublePositive GravityForms customization (Custom hook).
		add_filter( 'gf_nus_modify_supplier_id', [ $this, 'modify_doublepositive_supplier_id' ] );

		// 'Lead Group' field needs to be set to autopopulate via wp-admin GravityForms settings.
		add_filter( 'gform_field_value_leadgroup_auto_populate', [ $this, 'modify_doublepositive_leadgroup' ] );

		// Generate Quiq API call on form submission (GravityForms hook).
		add_action( 'gform_after_submission', [ $this, 'generate_quiq_api' ], 10, 2 );


		add_filter( 'cron_schedules', [ $this, 'sms_add_cron_interval' ] );
		add_action( 'sms_cron_hook', [ $this, 'sms_cron_exec' ] );


		$this->register_settings();
		$this->fetch_saved_settings();
		$this->init_sms_cron();
	}


	/**
	 * Need our cron job to run every 15 minutes (shorter intervals are highly discouraged by our hosting provider for performance reasons)
	 *
	 * TESTING NOTE: Update this to 1 minute, interval => 60
	 *
	 * @param array $schedules cron schedules from wp.
	 * */
	public function sms_add_cron_interval( $schedules ) {

		$schedules['fifteen_minutes'] = [
			'interval' => 900,
			'display'  => esc_html__( 'Every Fifteen Minutes' ),
		];

		return $schedules;

	}

	/**
	 * Load & integrate our custom admin settings menu with Gravity Forms
	 */
	public function register_settings() {

		if ( file_exists( GF_NUS_SMS_PATH . 'sms-rfi/class-gf-nus-sms-settings.php' ) ) {
			require_once GF_NUS_SMS_PATH . 'sms-rfi/class-gf-nus-sms-settings.php';
			\GFAddOn::register( 'GF_NUS_SMS_Settings' );
		}
	}

	/**
	 * Load SMS-related custom settings, saved via custom admin menu registered above
	 *
	 * @todo split other inputs (like custom Supplier ID & lead routing group ID) to these settings, so they can be changed as needed in the future without a code release.
	 */
	public function fetch_saved_settings() {

		$instance               = \GF_NUS_SMS_Settings::get_instance();
		$this->settings         = $instance->get_plugin_settings();
		$this->program_page_ids = explode( ',', $this->settings['sms_pilot_program_page_ids'] );
		$this->api_connection   = [
			'API_KEY'          => $this->settings['sms_quiq_api_key'],
			'API_SECRET'       => $this->settings['sms_quiq_api_secret'],
			'API_ACCESS_TOKEN' => $this->settings['sms_quiq_api_access_token'], // Currently unused.
			'API_TOKEN_ID'     => $this->settings['sms_quiq_api_token_id'], // Currently unused.
		];

		$this->quiq_config = [
			'CONTACT_POINT'     => $this->settings['sms_quiq_contact_point'],
			'DP_SUPPLIER_ID'    => intval( $this->settings['sms_doublepositive_supplier_id'] ),
			'TOPIC_1'           => $this->settings['sms_quiq_topic_1'],
			'TOPIC_2'           => $this->settings['sms_quiq_topic_2'],
			'MESSAGE_CONTENT_1' => $this->settings['sms_quiq_message_content_1'],
			'MESSAGE_CONTENT_2' => $this->settings['sms_quiq_message_content_2'],
		];

	}

	/**
	 * Fn: modify_doublepositive_supplier_id()
	 *
	 * Need to intercept the $supplier_id generated by our GravityForms-DoublePositive custom plugin,
	 * and then replace that ID with 377996, which tells DoublePositive to ignore the standard phone call follow-up.
	 * Reference: plugins/gravityforms-doublepositive/inc/class-populate-fields.php ==> populate_supplier_id()
	 *
	 * @todo Logic for other qualifiers (per word doc, non-military & non-international)
	 * @todo NOT SURE IF WE STILL NEED THIS. Per discussion w/Claire, right now it looks like certain form submissions are circumventing DoublePositive and only going to Eloqua. Leaving for now, but need to re-visit.
	 *
	 * @param int $supplier_id -- DoublePositive Supplier ID generated by standard form submission.
	 * @return int $supplier_id -- Changed to 377996 if applicable, otherwise returned unchanged
	 */
	public function modify_doublepositive_supplier_id( $supplier_id ) {

		$target_ids = $this->program_page_ids;
		global $post;

		// If our degree program matches the list of SMS-enabled programs, update supplier ID.
		if ( in_array( $post->ID, $target_ids ) ) {
			$supplier_id = $this->quiq_config['DP_SUPPLIER_ID'];
		}

		return $supplier_id;
	}

	/**
	 * Fn: modify_doublepositive_leadgroup()
	 *
	 * Need to intercept the $leadgroup generated by our GravityForms-DoublePositive custom plugin,
	 * and then replace that ID with 'NUSMSPilot'
	 *
	 * IMPORTANT: This is set up differently than the above modify_supplier_id() filter.
	 * In our existing GF:DoublePostive functionality, 'leadgroup' is generated after the Eloqua-integration webhook fires.
	 * THIS MEANS that at this point we don't have access to $post->ID, therefor cannot run our standard check for target page IDs.
	 *
	 * What we do instead is modify the 'leadgroup' hidden field within the GF settings (via wp-admin for the 'RFI Default' form),
	 * and set it up to 'populate dynamically'. GF allows this to happen via WordPress hook 'gform_field_value_[parameter_name]',
	 * and occurs when the form is submitted.
	 *
	 * Reference: plugins/gravityforms-doublepositive/inc/class-feed-processing.php ==> share_dp_data_to_eloqua()
	 * Reference: https://docs.gravityforms.com/using-dynamic-population/
	 *
	 * @param string $leadgroup -- DoublePositive 'leadgroup' (generally set to "DP" on non-SMS forms).
	 */
	public function modify_doublepositive_leadgroup( $leadgroup ) {

		$target_ids = $this->program_page_ids;
		global $post;

		if ( in_array( $post->ID, $target_ids ) ) {
			$leadgroup = 'NUSMSPilot'; // @todo: Move to wp-admin settings.
		}

		return $leadgroup;
	}


	/**
	 * Generate API call to Quiq for SMS messaging
	 * Reference: https://developers.goquiq.com/api/docs#operation/Send%20notification
	 *
	 * Called via gform_after_submission hook
	 * ref https://docs.gravityforms.com/gform_after_submission/
	 *
	 * IMPORTANT: Right now this absolutely depends on our Gravity Form having the following field IDs:
	 *    supplier_id => 61
	 *    zipcode     => 35
	 *    phone       => 34
	 *    country_code => 51
	 *  Right now this is fine since we're only using the SMS functionality on our RFI-Default form that's widely used across site
	 *
 	 * @todo Might be worth looking into a more robust solution for the above ^^. Maybe not worth the time though.
	 * @todo At the very least, need to build in some kind of error checking/safeguards.
	 *
	 * @param array $entry -- Data from the submitted form.
	 * @param array $form  -- Data about the form itself. Don't think we need this but leaving as a parameter for now, as a reminder that we have it if we need it.
	 *
	 */
	public function generate_quiq_api( $entry, $form ) {


		$supplier_id = intval( $entry[61] ); // GF field ID for our custom-created 'supplier_ID' field.
		$rfi_zipcode = $entry['35'];

		if ( $this->quiq_config['DP_SUPPLIER_ID'] !== $supplier_id || intval( $rfi_zipcode ) === 00000 ) {

			/**
			 * If our generated Supplier ID isn't the SMS-designed ID,
			 * or we have an international zip code (auto-populates to 00000 on front end for non-US phone numbers),
			 * Abort
			 */

			return;
		}

		$input_phone_number = $entry['34'];
		$input_country_code = $entry['51'];
		$user_phone         = '+' . $input_country_code . $input_phone_number; // i.e. '+16513343186' .

		// Query param 'allowMultipleSegments' to let us go over 160 characters in a single SMS. See API docs.
		define( 'QUIQ_ENDPOINT', 'https://nus.goquiq.com/api/v1/messaging/platforms/SMS/send-notification?allowMultipleSegments=true' );
		$url = QUIQ_ENDPOINT;

		$data = [
			'handle'       => $user_phone,
			'contactPoint' => $this->quiq_config['CONTACT_POINT'],
			'message'      => [
				'text' => $this->quiq_config['MESSAGE_CONTENT_1'],
			],
			'topic'        => $this->quiq_config['TOPIC_1'],
		];

		$payload = wp_json_encode( $data );

		$args = [
			'body'    => $payload,
			'headers' => [
				'Authorization' => 'Basic ' . base64_encode( $this->api_connection['API_KEY'] . ':' . $this->api_connection['API_SECRET'] ),
				'Content-Type'  => 'application/json',
			],
		];

		$response = wp_remote_post( $url, $args );

		if ( 200 === $response['response']['code'] ) {

			// Schedule second API call.

			/**
			 * In plugin activation hook, we create a custom 'wp_sms_rfi' db table.
			 * We use this table to manage our SMS #2 schedule.
			 * Upon successful SMS #1 send, we create a db row for the phone number and timestamp.
			 * WP-Cron then uses this table to send out SMS #2 to all entries older than 24 hours old.
			 *
			 * @todo if API call fails, should implement logic to process form normally
			 */

			global $wpdb;

			$table_name = 'wp_sms_rfi';
			$timestamp  = gmdate( 'Y-m-d H:i:s' );

			$table_data = [
				'phone_number'  => $user_phone,
				'rfi_timestamp' => $timestamp,
			];

			$wpdb->insert( $table_name, $table_data );

		}

		/**
		 * @todo build in some sort of error handling for if API response is anything other than 200. Form still submits as intended, but we need to at least update our data integrations so the enrollment teams know the SMS send failed.
		 */

	}


	/**
	 * Init cron event schedule.
	 *
	 * @return void
	 */
	public function init_sms_cron() {

		if ( ! wp_next_scheduled( 'sms_cron_hook' ) ) {

			wp_schedule_event( time(), 'fifteen_minutes', 'sms_cron_hook' );

		} else {
			// For testing/debug purposes:
			// $temp = gmdate( 'Y-m-d H:i:s', wp_next_scheduled( 'sms_cron_hook' ) );
			// error_log("Next scheduled sms cron: " . $temp );
		}

	}


	/**
	 * Execute cron job
	 *
	 * Fetch all rows from custom 'wp_sms_rfi' db table.
	 * Check 'timestamp' value for each row
	 * Any timestamp more than 24 hours old, send another Quiq API call with Message #2
	 * Then, delete the row from the table.
	 *
	 * @todo a lot of this was copy/pasted on the fly due to imminent deadlines. Need to DRY it up at some point.
	 **/
	public function sms_cron_exec() {

		/**
		 * Fetch saved admin settings
		 */
		$instance               = \GF_NUS_SMS_Settings::get_instance();
		$this->settings         = $instance->get_plugin_settings();
		$this->program_page_ids = explode( ',', $this->settings['sms_pilot_program_page_ids'] );
		$this->api_connection   = [
			'API_KEY'          => $this->settings['sms_quiq_api_key'],
			'API_SECRET'       => $this->settings['sms_quiq_api_secret'],
			'API_ACCESS_TOKEN' => $this->settings['sms_quiq_api_access_token'], // Currently unused.
			'API_TOKEN_ID'     => $this->settings['sms_quiq_api_token_id'], // Currently unused.
		];

		$this->quiq_config = [
			'CONTACT_POINT'     => $this->settings['sms_quiq_contact_point'],
			'TOPIC_2'           => $this->settings['sms_quiq_topic_2'],
			'MESSAGE_CONTENT_2' => $this->settings['sms_quiq_message_content_2'],
			'DP_SUPPLIER_ID'    => intval( $this->settings['sms_doublepositive_supplier_id'] ),
		];



		$now = gmdate( 'Y-m-d H:i:s' ); // Match format we input into database.

		// Fetch wpdb rows from sms_rfi table.
		global $wpdb;

		$rows = $wpdb->get_results(
			$wpdb->prepare(
				'
				SELECT *
				FROM wp_sms_rfi
				ORDER BY sms_id
				'
			)
		);


		foreach ( $rows as $row ) {

			// Get difference between timestamp in hours.
			$diff = ( strtotime( $now ) - strtotime( $row->rfi_timestamp ) ) / ( 60 * 60 );

			// If timestamp is more than THIRTY MINUTES old, fire the API for SMS #2 and then delete the row from the table.
			// FOR TESTING: check 1 minute (1/60) instead.
			// if ( $diff >= 0.016 ) {
			if ( $diff >= 0.5 ) {


				// Query param 'allowMultipleSegments' to let us go over 160 characters in a single SMS. See API docs.
				$url = 'https://nus.goquiq.com/api/v1/messaging/platforms/SMS/send-notification?allowMultipleSegments=true';

				$data = [
					'handle'       => $row->phone_number,
					'contactPoint' => $this->quiq_config['CONTACT_POINT'],
					'message'      => [
						'text' => $this->quiq_config['MESSAGE_CONTENT_2'],
					],
					'topic'        => $this->quiq_config['TOPIC_2'],
				];

				$payload = wp_json_encode( $data );

				$args = [
					'body'    => $payload,
					'headers' => [
						'Authorization' => 'Basic ' . base64_encode( $this->api_connection['API_KEY'] . ':' . $this->api_connection['API_SECRET'] ),
						'Content-Type'  => 'application/json',
					],
				];


				$response = wp_remote_post( $url, $args );

				if ( 200 === $response['response']['code'] ) {
					// If SMS #2 was sent successfully, delete the row from the table.
					$wpdb->delete(
						'wp_sms_rfi',
						[ 'sms_id' => $row->sms_id ]
					);

				}
			}
		}


	}

}
